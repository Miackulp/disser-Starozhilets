\chapter{Описание математической модели}\label{ch:ch3}

В данном разделе приводится полное математическое описание предлагаемой мезоскопической модели с описанием процедуры моделирования автомагистрали с ее использованием.
\section{Структура модели}
\label{sec:model}
\subsection{Внутренние свойства модели}
\label{sec:graph_structure}
Транспортная сеть представляет собой связный ориентированный граф \(\mathbf{G} = (\mathbf{V}, \mathbf{E})\),
где \(\mathbf{V}\) - множество вершин, \(\mathbf{E} = \{(i, j)\}\) - множество ветвей графа.
На граф также накладываются ограничения на максимальную и минимальную степень вершин \(d(i)$: $\min(d(i)) = 1\) и~\(\max(d(i)) = 3\).
Также \(\forall i: d(i) > 1 \rightarrow \exists j, l \in \mathbf{V} : (j, i), (i, l) \in \mathbf{E}\), т.е. не существует вершины, в которой только заканчиваются несколько ветвей, и не существует вершины, в которой только начинаются несколько ветвей.

Определим теперь все типы вершин графа в зависимости от их степеней.
\begin{enumerate}
  \item \(d(i) = 1\). В данном случае существует два варианта:
  \begin{enumerate}
    \item \(i:\ \exists (i,j)\in \mathbf{E}\). Такие вершины будем называть \emph{вершинами-въездами}. Вершины въезды образуют множество \(\mathbf{V}_\text{in}\) и являются источниками автомобильно-транспортных средств(АТС) в рассматриваемой модели.
    \item \(i:\ \exists (j,i)\in \mathbf{E}\). Такие вершины будем называть \emph{вершинами-съездами}. Вершины съезды образуют множество \(\mathbf{V}_\text{out}\) и являются стоками автомобилей в рассматриваемой модели.
  \end{enumerate}
  \item \(d(i) = 2\). Это внутренние вершины модели образующие множество \(\mathbf{V}_\text{int}\).
  \item \(d(i) = 3\)~--- вершины-центры перекрестков дорожно-транспортной сети. Данные вершины также входят в множество \(\mathbf{V}_\text{int}\), но образуют еще два подмножества.
  \begin{enumerate}
    \item Если \(\exists (i, j) \in \mathbf{E},\ (i, k) \in \mathbf{E} : j\neq k \), то такие вершины образуют множество \(\mathbf{V}_\text{sep}\)~--- вершины в которых происходит разделение потоков в дорожно-транспортной сети.
    \item Если \(\exists (j, i) \in \mathbf{E},\ (k, i) \in \mathbf{E} : j\neq k \), то такие вершины образуют множество \(\mathbf{V}_\text{mer}\)~--- вершины, в которых происходит слияние потоков в дорожно-транспортной сети.
  \end{enumerate}
\end{enumerate}
Таким образом, \(\mathbf{V} = \mathbf{V}_\text{int} \cup \mathbf{V}_\text{out} \cup \mathbf{V}_\text{in}\)~--- все вершины распределены по трем непересекающимся группам. Вершины же перекрестки с \(d(i) = 3\) дополнительно разделены по типу перекрестка причем \(V_\text{sep}\bigcap V_\text{mer} = \emptyset\). Ввиду того, что в данной работе рассматриваются только автомагистрали, то вершины с \(d(i) = 4\) и более не встречаются.

Разделим схожим образом ребра инцидентные этим вершинам. Рассмотрим для этого некоторое ребро \((i,j)\).
\begin{enumerate}
  \item Если \(i\in \mathbf{V}_\text{in}\), то ребро \((i,j)\)~--- это ребро-въезд. Такие ребра образуют множество въездов \(\mathbf{E}_\text{in}\).
  \item Если \(j\in \mathbf{V}_\text{out}\), то ребро \((i,j)\)~--- это ребро-съезд. Такие ребра образуют множество съездов \(\mathbf{E}_\text{out}\).
  \item Если \(i\in \mathbf{V}_\text{int}\) и \(j\in \mathbf{V}_\text{int}\), то ребро \((i,j)\)~--- это внутреннее ребро модели. Такие ребра образуют множество внутренних ребер модели \(\mathbf{E}_\text{int}\).
\end{enumerate}
Также как и с вершинами \(\mathbf{E} = \mathbf{E}_\text{int} \cup \mathbf{E}_\text{out} \cup \mathbf{E}_\text{in}\) за исключением случая, когда модель представляет из себя одно ребро, который в этой работе не рассматривается.

Определим теперь понятие состояния модели в момент времени \(t\).
Для этого нам понадобится понятие автомобильной группы на ветви \((i, j): \mathbf{A}^t_k = \{\mathrm{Pos}_k, V_k, N_k\}\), обладающей следующими характеристиками:
\begin{enumerate}
    \item \(\mathrm{Pos}_k\)~--- позиция начала группы относительно начала ветви, на которой она расположена.
    \item \(V_k\)~--- скорость группы АТС.
    \item \(N_k\)~--- размер группы АТС из \(\mathbb{R}_{\geq 0} = \mathbb{R}_+\).
\end{enumerate}

Пусть теперь \(\mathbf{A}^t_{i,j} = \{\mathbf{A}^t_k\}\)~--- упорядоченное множество автомобильных групп на ветви \((i,j)\). Причем \(\forall l, m: l<m \rightarrow \mathrm{Pos}_l > \mathrm{Pos}_m\)~--- группы не могут обгонять друг друга.

Таким образом, введем состояние системы в момент времени \(t\) как \(\mathbf{A}^t = \{\mathbf{A}^t_{i,j}\} \cup \{A^t_{\text{out}, i, j}\}\), т.е. положение, скорость, размер и тип всех автомобильных групп на всех ветвях дорожно-транспортной сети. 
Группы АТС \(\{A^t_{\text{out}, i, j}\}\) представляют собой специальные группы-буферы. Их особые свойства рассматриваются в разделе Общих свойств модели.

Для расчетов нам также понадобится понятие потенциала трансфера \(\text{Tr}_{(i, j), k}^t (\mathbf{A}^t, \mathbf{A}^{t-1})\)~--- число АТС, которые могут съехать с ветви \((i,j)\) на ветвь \((j,k)\) в интервал времени от \(t-1\) до \(t\). 
Данная величина вычисляется заново на каждой временной итерации в зависимости от состояния системы.


\subsection{Внешние свойства модели}
\label{sec:graph_structure}
Определим теперь свойства модели задаваемые при ее инициализации.

Рассмотрим предварительно три ветви с \(d(j) = 3:\ (i, j), (j, k_1), (j, k_2)\). 
В данной работе мы считаем \((j, k_1)\) продолжением автомагистрали, а \((j, k_2)\)~--- съездом с нее. Данное распределение полностью задается в момент инициализации модели.

Перечислим все внешние параметры модели для каждой ветви \((i, j) \in \mathbf{E}\) графа \(\mathbf{G}\).
\begin{enumerate}
    \item Длина ветви \(l_{i, j}\).
    \item Число полос, по которым разрешено движение автомобилей по данной ветви \(n_{i, j}\).
    \item \(I_{i, j} = \{0, 1\}\)~--- идентификатор того, является ветвь съездом или нет. Если является, то \(I_{i, j} = 1\).
    \item Функция скорости для данной ветви \(V = f_{i,j}(\rho)\), \(f_{i,j}: \mathbb{Q}_+ \rightarrow \mathbb{Q}_+\), где \(\rho\in\mathbb{R}_+\)~--- плотность АТС.
        В данной работе рассматриваются только ограниченные непрерывные монотонно убывающие функции скорости.
        Процедура получения данной функции из экспериментальных данных детально описана в разделе~\ref{ch:ch2}.
    \item Матрица перемешивания в узле \(j\) в момент времени \(t\), задаваемая функцией \(M_j(t)\).
        В случае если \(j: \nexists (j,k) \in \mathbf{E}_\text{out} \rightarrow \forall t: M_j(t) = 0\).
    \item Интенсивность источника в узле \(i\) в момент времени \(t\), задаваемая функцией \(F_i(t)\). Для всех \(i: i\notin \mathbf{V}_\text{in} \rightarrow \forall t: F_i(t) == 0\).
\end{enumerate}

Также у каждой ветви есть буфер АТС \(A^t_{\text{out}, i, j} = \{\mathrm{Pos}_{\text{out}, i, j}, V_{\text{out}, i, j}, N_{\text{out}, i, j}\}\), представляющий из себя группу АТС с \(\mathrm{Pos}_{\text{out}, i, j} = l_{i, j},\ V_{\text{out}, i, j} = 0\). 
Данная группа моделирует очередь на съезд с ребра \((i, j)\)~--- т.е. группу \((j, k)\) с \(I_{i, j} = 1\). 
Работа с данной группой детально описана в разд. 
Алгоритмов перемещения и объединения групп АТС~\ref{sec:calc_functions}.

Будем считать, что в модели все автомобили имеют фиксированный размер \(L_\text{car}^\text{avg}\).
В дальнейшем, путем изменения этой величины можно также исследовать зависимость поведения автомагистрали от состава потока автомобилей.
С его помощью получаем максимальное число автомобилей на ветви \((i,j)\) как \(N^{i,j}_\text{max} = \frac{l_{i,j} \cdot n_{i, j}}{L_\text{car}^\text{avg}}\).

Введем также понятие динамического размера автомобилей \(L_\text{car}(V) = L_\text{car}^\text{avg} + a\cdot V\), где \(a = 0.504\). 
Данная величина отражает тот факт, что автомобили в среднем на определенной скорости не сближаются сильнее некоторого расстояния. 
Сама же константа \(a\), как и данное приближение, взята из книги~\cite{gasn2017introd}.
Видно, что данное соотношение~--- это соотношение из модели Танака~\ref{subsec:ch1/sec1/sub2} без квадратичного члена отвечающего за влияние аномальных погодных условий (дождь, снег).

Таким образом, получаем, что все характеристики автомобильной группы ограничены сверху.
\begin{enumerate}
  \item Положение \(\mathrm{Pos}_k\) группы АТС длиной ветви на которой группа находится.
  \item Скорость \(V_k\) ограничена максимальной скоростью на ветви, которую можно определить из функции скорости $f_{i,j}(\rho)$.
  \item Максимальный размер \(N_k\) ограничен максимальным числом автомобилей на ветви \(N^{i,j}_\text{max}\).
\end{enumerate}

Однако поскольку в нашей модели все группы АТС движутся так, как будто каждый автомобиль в группе обладает полным знанием обо всех других автомобилях, то это накладывает на группы логическое ограничение на их размер, так как сложно ожидать такого поведения у АТС в огромной группе. 
Мы в данной работе считаем разумным ограничение в \(N_\text{max} = 20\) АТС.

Также нам понадобится величина среднего ускорения группы АТС \(a_\text{avg}\) для ограничения увеличения скорости движения групп АТС по ветвям автомагистрали. 
В данной работе величина ускорения взята за константу и равна \(2.2\ \text{м/c2}\) (см.~\cite{long2000acceleration}).


\section{Алгоритмы перемещения и объединения групп АТС}
\label{sec:calc_functions}
Определим как группы АТС объединяются в одну, как переезжают с одной ветви на другую, как движутся по ветви и как съезжают на ветви-съезды.
Также определим функцию расчета \(\text{Tr}_{(i, j), k}^t (\mathbf{A}^t, \mathbf{A}^{t-1})\) на каждом временном шаге.

\subsection{Движение групп АТС по ветви}
На каждой итерации алгоритма надо рассчитать новое положение групп АТС для каждой ветви.
Перерасчет положения групп а также их скорости производит функция \(\text{group\_mover}(\mathbf{A}^t_{i,j},\ k,\ (i,j),\ \tau,\ t)\) по алгоритму~\ref{group_mover}.
Расчеты по данному алгоритму сводятся к следующим шагам.
\begin{enumerate}[leftmargin=2.05cm,label=Шаг \arabic*.,ref=\arabic*]
  \item Для выбранной группы АТС \(\mathbf{A}^t_k$ на ветви $(i,j)\) рассчитываем ее скорость \(V_k'\) на основании плотности автомобилей на участке автодороги перед ней.
  \item Рассчитываем новое положение группы АТС.
  \item Если группа оказалась в конце ветви:
  \begin{enumerate}
    \item рассчитать сколько времени она ехала до конца ветви;
    \item в соответствии с матрицей перемешивания часть группы добавляется в буфер-группу \(A^t_{\text{out}, i, j}\);
    \item оставшаяся часть группы \(\mathbf{A}^t_k\) пытается переехать на следующую для нее ветвь с \(I_{j, m_1} = 0\);
    \item группа-буфер \(A^t_{\text{out}, i, j}\) пытается переехать на следующую для нее ветвь с \(I_{j, m_1} = 1\).
  \end{enumerate}
\end{enumerate}

\begin{algorithm}[!ht]
    \caption{Алгоритм расчета положения и скорости группы АТС}
    \label{group_mover}
    \begin{algorithmic}
        \REQUIRE \(\mathbf{A}^t_{i,j}\)~--- множество характеристик автомобильных групп на ветви; \\
                 \(k\)~--- индекс рассматриваемой автомобильной группы; \\
                 \((i,j)\)~--- рассматриваемая ветвь графа; \\
                 \(\tau\)~--- временной шаг; \\
                 \(t\)~--- текущий момент времени;
        \IF {\(\mathrm{Pos}_k = l_{i,j}\)}
            \STATE Если группа АТС уже в конце ветви то она просто пытается переехать на следующую ветвь
            \STATE Пусть \(j' : (j, j') \in \mathbf{\widetilde{E}}$~--- ветвь c $I_{j, j'} = 0\)
            \STATE \(\text{group\_transferrer}(\mathbf{A}^t,\ \mathbf{A}^{t-1},\ k,\ (i,j),\ (j,j'),\ \tau')\) из Алгоритма~\ref{group_transferrer}
            \RETURN 0
        \ENDIF
        \STATE \(\mathrm{Pos}_k += V_k \cdot \tau\)
        \STATE Пусть \(\rho = \frac{\sum_{m=k+1}^{\text{len}(\mathbf{A}^t_{i,j})} N_m}{l_{i,j} \cdot n_{i,j}}\)~--- плотность АТС на участке ветви \((i,j)\) перед группой АТС \(k\), тогда \(V_k' = f_{i,j}(\rho)\)~--- новая скорость группы АТС.
        \IF {\(V_k' - V_k > a_\text{avg} \cdot \tau\)}
            \STATE \(V_k' = V_k + a_\text{avg} \cdot \tau\)
        \ENDIF
        \IF {\(\mathrm{Pos}_k \geq l_{i,j}\) и \(k = 0\)}
            \STATE \(\tau' = \tau \cdot \frac{\mathrm{Pos}_k - l_{i,k}}{V_k \cdot \tau}\)~--- 'оставшееся' время движения автомобильной группы
            \STATE \(\mathrm{Pos}_k = l_{i,k}\)
            \STATE Добавим АТС в группу-буфер \(\mathbf{A}^t_{\text{out}, i, j}\)
            \STATE \(N_{\text{out}, i, j} += N_k \cdot M_j(t)\)
            \STATE \(N_k = N_k \cdot (1 - M_j(t))\)
            \STATE Оставшиеся АТС должны продолжить движение по магистрали
            \STATE Пусть \(j' : (j, j') \in \mathbf{\widetilde{E}}\)~--- ветвь c \(I_{j, j'} = 0\)
            \STATE \(\text{group\_transferrer}(\mathbf{A}^t,\ \mathbf{A}^{t-1},\ k,\ (i,j),\ (j,j'),\ \tau')\) по Алгоритму~\ref{group_transferrer}
            \STATE Группа-буфер пытается съехать
            \STATE Пусть \(j'' : (j, j'') \in \mathbf{\widetilde{E}}\)~--- ветвь c \(I_{j, j''} = 0\)
            \STATE \(\text{group\_transferrer}(\mathbf{A}^t,\ \mathbf{A}^{t-1},\ k,\ (i,j),\ (j,j''),\ \tau')\) по Алгоритму~\ref{group_transferrer}
        \ELSE
            \IF {\(\mathrm{Pos}_k \geq \mathrm{Pos}_{i,k-1}\)}
                \STATE \(\mathrm{Pos}_k = \mathrm{Pos}_{k-1} - L_\text{car}(V_{k-1}) \cdot N_{k-1}\)
            \ENDIF
            \STATE \(\text{group\_union}(\mathbf{A}_{i,j},\ k,\ (i,j),\ t)\)
        \ENDIF
        \STATE Если группа АТС \(\mathbf{A}^t_k\) все еще существует \(V_k = V_k'\)
    \end{algorithmic}
\end{algorithm}

Заметим, что функция \(\text{group\_transferrer}\)~алгоритм~3 вызывается тут с временным шагом \(\tau'\), что означает что группа АТС при переезде на новую ветвь будет двигаться меньшее количество времени.


\subsection{Объединение двух групп АТС}
После изменения положения группы АТС на ветви нужно проверить не может ли она быть объединена с какой либо другой группой.
Поскольку группы движутся только вперед и в нашей модели не могут обгонять друг друга, то проверка на возможность
объединения идет только с группой перед рассматриваемой.
То есть для группы АТС \(j\) рассматривается возможность ее слияния с группой \(j-1\).
За слияние групп отвечает функция \(\text{group\_union}(\mathbf{A}^t_{i,j},\ k,\ (i,j),\ t)\), работающая по алгоритму~\ref{group_union}.

\begin{algorithm}[!ht]
    \caption{Алгоритм объединения групп АТС}
    \label{group_union}
    \begin{algorithmic}
        \REQUIRE \(\mathbf{A}^t_{i,j}\)~--- множество характеристик автомобильных групп на ветви; \\
                 \(k\)~--- индекс рассматриваемой автомобильной группы; \\
                 \((i,j)\)~--- рассматриваемая ветвь графа; \\
                 \(t\)~--- текущий момент времени;
        \IF{\(k = 0\)}
            \STATE Группу не с чем объединять так как она самая первая
        \ELSE
            \IF{\(\mathrm{Pos}_{k-1} - \mathrm{Pos}_k \leq L_\text{car}(V_{k-1}) \cdot N_{k-1}$ и $N_{k-1} + N_k \leq N_\text{max}\)}
                \STATE Объединяем группы в одну
                \IF{\(k - 1 = 0\) и \(\mathrm{Pos}_(k - 1) = l_{i,j}\)}
                    \STATE \(N^{j}_\text{exit} += N_k \cdot M_j(t)\)
                    \STATE \(N_{k-1} += N_k \cdot (1 - M_j(t))\)
                \ELSE
                    \STATE \(N_{k-1} += N_k\)
                \ENDIF
                \STATE \(\text{del} \mathbf{A}^t_k\)~--- группа \(k\) удаляется
            \ENDIF
        \ENDIF
    \end{algorithmic}
\end{algorithm}


\subsection{Перемещение групп АТС между ветвями}
Когда группа автомобилей достигает конца ветви, на которой она находится, требуется определить какая ее часть переедет на
следующий сегмент автомагистрали и какое положение и скорость примет на новой ветви.
За данные расчеты отвечает функция \(\text{group\_transferrer}(\mathbf{A}^t,\ \mathbf{A}^{t-1}, k,\ (i,j),\ (j,j'),\ \tau,\ t)\) по алгоритму~\ref{group_transferrer}.
Расчеты по данному алгоритму сводятся к следующим шагам.
\begin{enumerate}[leftmargin=2.05cm,label=Шаг \arabic*.,ref=\arabic*]
  \item Определяем индекс новой группы АТС на ветви \((j,j')\).
  \item Определяем, может ли группа переехать на новую ветвь полностью. Если да:
  \begin{enumerate}
    \item создаем новую группу АТС в конце ветви \((j,j')\) с \(N_{k'} = N_k\).
    \item Удаляем группу \(k\) из \(\mathbf{A}^t_{i,j}\).
  \end{enumerate}
  \item Если нет:
    \begin{enumerate}
    \item создаем новую группу АТС в конце ветви \((j,j')\) с \(N_{k'} = N'\), где \(N'\)~--- число АТС которые могут переехать.
    \item Уменьшаем размер группы \(k\) на величину \(N'\).
  \end{enumerate}
  \item Вызываем функцию для перемещения новой группы по ветви \((j,j')\).
\end{enumerate}

\begin{algorithm}[!ht]
    \caption{Алгоритм перемещения группы АТС на новую ветвь}
    \label{group_transferrer}
    \begin{algorithmic}
        \REQUIRE \(\mathbf{A}^t\)~--- состояние системы в текущий момент времени; \\
                 \(\mathbf{A}^{t-1}\)~--- состояние системы в предыдущий момент времени; \\
                 \(k\)~--- индекс рассматриваемой автомобильной группы; \\
                 \((i,j)\)~--- ветвь с которой хочет съехать группа АТС; \\
                 \((j,j')\)~--- ветвь на которую хочет съехать группа АТС; \\
                 \(\tau\)~--- временной шаг; \\
                 \(t\)~--- текущий момент времени; \\
        \IF {\(N_k \leq \text{Tr}_{(i, j), j'}^t (\mathbf{A}^t, \mathbf{A}^{t-1})\)}
            \STATE Группа полностью может переехать на новую ветвь
            \STATE Пусть \(k' = \text{len}(\mathbf{A}^t_{j,j'}) + 1\)~--- индекс новой группы АТС
            \STATE Создаем новую группу АТС на ребре \((j,j')\) с индексом \(k'\) и характеристиками:
            \STATE \(\mathrm{Pos}_{k'}  = 0,\ V_{k'}  = f_{j,j'}(\rho), N_{k'} = N_k\)
            \STATE Удаляем группу \(k\) из \(\mathbf{A}^t_{i,j}\)
            \STATE \(\text{group\_mover}(\mathbf{A}^t_{j,j'},\ k',\ (j,j'),\ \tau,\ t)\)
        \ELSE
            \STATE Только часть группы переезжает на новую ветвь
            \STATE Пусть \(k' = \text{len}(\mathbf{A}^t_{j,j'}) + 1\)~--- индекс новой группы АТС
            \STATE Создаем новую группу АТС на ребре \((j,j')\) с индексом \(k'\) и характеристиками:
            \STATE \(\mathrm{Pos}_{k'}  = 0,\ V_{k'}  = f_{j,j'}(\rho), N_{k'} = \text{Tr}_{(i, j), j'}^t (\mathbf{A}^t, \mathbf{A}^{t-1})\)
            \STATE \(N_k -= \text{Tr}_{(i, j), j'}^t (\mathbf{A}^t, \mathbf{A}^{t-1})\)
            \STATE \(\text{group\_mover}(\mathbf{A}^t_{j,j'},\ k',\ (j,j'),\ \tau,\ t)\)
        \ENDIF
    \end{algorithmic}
\end{algorithm}

\section{Расчетный цикл}
\label{sec:calc_loop}

\subsection{Расчет потенциала трансфера}
Для начала определим то, как в конце каждой итерации рассчитывается сколько АТС могут переехать с ветви \((i,j)\) на ветвь \((j,k)\).
Особенностью является то, что алгоритм рассчитывает не потенциал трансфера для ветви \((i,j)\) на ветвь \((j,k)\), а все потенциалы трансфера \(\forall i: (i,j)\in \mathbf{E} \rightarrow \text{Tr}_{i, j}^k\).
То есть для ветви \((j,k)\) рассчитываются всевозможные \(\text{Tr}_{i, j}^k\).

Данный расчет производит функция \(\text{Tr\_calculator}(\mathbf{A}^t, \mathbf{A}^{t-1},\ (j,k),\ \tau)\) по алгоритму~\ref{max_transfer_calculation}.
В процессе расчета нам также понадобятся величины \(Q_(i,j) = \text{max}(\rho\cdot f_{i,j}(\rho))\)~--- максимальный поток АТС на ветви \((i,j)\),
\(N^{i,j}_\text{max}\)~--- максимальное число АТС на ветви \((i,j)\) и \(N^t_{i,j} = \sum_{m=0}^{\text{len}(\mathbf{A}^t_{i,j})} N_m\)~--- текущее число АТС на ветви \((i,j)\).

Процедура расчета сводится к определению двух величин:
\begin{enumerate}[label=\arabic*),ref=\arabic*]
  \item \(P_i\)~--- потенциальное количество АТС которые могут доехать до конца ветви \((i,j)\) предшествующей \((j,k)\);
  \item \(N_\text{total}\)~--- сколько всего АТС может переехать на ветвь \((j,k)\) на основании ее вместимости и максимального потока на ней.
\end{enumerate}
В итоге число АТС, которые могут переехать с ветви \((i,j)\) на ветвь \((j,k)\) определяется формулой \(N_\text{total} \cdot \frac{P_i}{\sum P_i}\).


\begin{algorithm}[!hb]
    \caption{Алгоритм расчета \(\text{Tr}_{i, j}^k\)}
    \label{max_transfer_calculation}
    \begin{algorithmic}
        \REQUIRE \(\mathbf{A}^t\)~--- состояние системы в текущий момент времени; \\
                 \(\mathbf{A}^{t-1}\)~--- состояние системы в предыдущий момент времени; \\
                 \((j,k)\)~--- ветвь для которой проводится расчет; \\
                 \(\tau\)~--- временной шаг; \\
        \STATE Пусть \(\mathbf{I} = \{i : (i,j) \in \mathbf{E}\}\)~--- множество ветвей предшествующих рассматриваемой
        \FORALL{\(i \in \mathbf{I}\)}
            \STATE \(P_i = 0\)~--- число АТС которые теоретически могут достигнуть конца их ветви на следующей временной итерации
            \FORALL{\(m=0;\ l\leq \text{len}(\mathbf{A}^t_{i,j});\ m++\)}
                \IF{\(\mathrm{Pos}_m + V_m \cdot \tau \geq m_{i,j}\)}
                    \IF {\((j,k) \in \mathbf{E}_\text{int}\)}
                        \STATE \(P_i += N_m \cdot (1 - M_j(t))\)
                    \ELSE
                        \STATE \(P_i += N_m \cdot M_j(t)\)
                    \ENDIF
                \ENDIF
            \ENDFOR
        \ENDFOR
        \STATE Определим \(N_\text{total}\)~--- сколько всего АТС может переехать на ветвь \((j,k)\)
        \IF {\(N^{j,k}_\text{max} - N^{j,k}_\text{cur} < Q_(j,k)\)}
            \STATE \(N_\text{total} = N^{j,k}_\text{max} - N^{j,k}_\text{cur}\)
        \ELSE
            \STATE \(N_\text{total} = Q_(j,k)\)
        \ENDIF
        \FORALL {\(i \in \mathbf{I}\)}
            \STATE \(\text{Tr}_{i, j}^k = N_\text{total} \cdot \frac{P_i}{\sum P_i}\)
        \ENDFOR
    \end{algorithmic}
\end{algorithm}

\subsection{Процедура расчета}
Процедура перехода от состояния системы \(\mathbf{A}^{t-1}\) к состоянию \(\mathbf{A}^t\) происходит в соответствии со следующим циклом.
\begin{enumerate}
  \item \(\forall (i, j) \in \mathbf{V}_\text{out}:\) удаляем все группы АТС находящиеся на этой ветви, так как это ветви - стоки.
  \item \(\forall (i, j) \in \mathbf{V}_\text{in}:\) формируем новую группу АТС \(k' = \text{len}(\mathbf{A}^t_{i,j}) + 1\) с \(\mathrm{Pos}_{k'}  = 0,\ V_{k'}  = f_{j,j'}(\rho), N_{k'} = F_i(t)\).
  \item Пусть \(\mathbf{C}\)~--- некоторое подмножество ветвей графа. Будем выполнять следующие действия пока оно не пусто:
  \begin{enumerate}
      \item \(\mathbf{C} = \{(i, j)\}, (i, j) \in \mathbf{V}_\text{out}\).
      \item \(\forall (i, j) \in \mathbf{C} \rightarrow \forall \mathbf{A}^t_k \in \mathbf{A}^t_{i,j} \rightarrow \text{group\_mover}(\mathbf{A}^t_{i,j},\ k,\ (i,j),\ \tau,\ t)\)~--- для каждой группы АТС рассчитываем ее новое положение. Причем расчет производится упорядоченно по убыванию величины \(\mathrm{Pos}_{k}\), причем группы-буферы обсчитываются первыми.
      \item \(\mathbf{C'} = \{(k, i)\}: \exists j: (i, j) \in \mathbf{C}\)~--- формируем новое подмножество для расчетов.
      \item \(\mathbf{C} = \mathbf{C'}\).
  \end{enumerate}
  \item \(\forall (i, j) \in \mathbf{E} \rightarrow \forall \mathbf{A}^t_k \in \mathbf{A}^t_{i,j} \rightarrow \text{group\_union}(\mathbf{A}^t_{i,j},\ k,\ (i,j),\ t)\)~--- объединяем группы АТС, если это возможно.
\end{enumerate}

Таким образом, получаем состояние системы \(\mathbf{A}^t\).

\FloatBarrier
